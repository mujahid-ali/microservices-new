Do not use this in prod: spring.jpa.hibernate.ddl-auto=create-drop
this can be used in prod: spring.jpa.hibernate.ddl-auto=none along with liquibase and flyway library.


Inter Service communication:
1: Synchronus
2: Asynchronus
1: sync -> via http: RestTemplate(by default from Springboot) and WebClient(From Spring webflux project) are two method
By default WebClient makes async request, for sync we need to use .block() method.
We will call the another service using WebClient using the uri of that service
EX: InventoryResponse[] inventoryResponses = webClient.get()
                    .uri("http://localhost:8082/api/inventory",
                            uriBuilder -> uriBuilder.queryParam("skuCode", skuCodes).build())
                    .retrieve()
                    .bodyToMono(InventoryResponse[].class)
                    .block();

Service Discovery(Eureka): We can not expect a fix URL for a particular micro-service bcz there can be multiple instance of
 a microservice and each instance can have a dynamic ip address. Service Discovery helps in this scenario. There should be
 a Discovery Server which should have all the information about the services(ex: service-name, ip-add, uri,ports, isUp etc).
 When a service initialized then it will try to register itself with Discovery server with all the info about it, this data is
 known as service registry.
 When Service A wants to communicate with Service B then first it will check with the Discovery server for Service B,
 the Discovery server will tell the info(ip,port) about Service B to Service A. Now A can use the info to communicate with B.
 Here we have avoided the hardcoding of urls of services by using discovery server.
 Discovery server also shared it's copy of service registry to services so in case Discovery Server is down then service
 can refer their own local copy of registry(it might not be latest but still serves purpose).

 https://spring.io/projects/spring-cloud-netflix Service Discovery: Eureka instances can be registered
 @EnableEurekaServer annotation will make the app/class as Eureka Discovery Server.
 @EnableEurekaClient annotation will make the service as discoverable for eureka server and
  adding the eureka server info in app.prop file will tell about the server it should add: eureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka

@LoadBalanced
WebClient.builder
If there are multiple instances of a service running then the calling service might not be able to figure out which instance to
invoke, so client side load balancing is used to resolve this issue.

If Discovery server is down then services will look into their local registry and make the calls, but if all the services are
down and then restart but discovery server is still down then they might not be able to communicate, in this case discovery is required.

API Gateway: Acts as an entry points and routes the user requests. Rules need to be configured for routing.
Routing based on Request Headers
Authentication
Security
Load Balancing: Decide which instance of service to call.
SSL Termination
Spring cloud gateway(spring framwork's api gateway) having some features like Security, rate-limiting, circuit-
breaker integration, path rewriting etc.
Doc for more details of predicate: https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories


KeyCloak: docker run -p 8181:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:18.0.0 start-dev
We are using keycloak for securing our application. we can use above docker command to use it.
@EnableWebFluxSecurity is no mvc/web else @EnableWebSecurity to enable security.
configure method can be override for defining security rules.
Run command in terminal: docker run -p 8181:8080 -e KEYCLOAK_ADMIN=admin -e KEYCLOAK_ADMIN_PASSWORD=admin quay.io/keycloak/keycloak:18.0.0 start-dev
go to :-> http://localhost:8181/ -> Administration Console -> admin/admin -> add realm -> spring-boot-microservices-realm -> create
-> clients -> create -> client ID: spring-cloud-client, protocol:openid connect -> save -> select access type: confidential,
disable: direct and flow, enable: Service Accounts Enabled: ON -> save -> Credentials -> Secret

Open postman:-> Authorization -> Type: OAuth2.0 ->
Access Token URL: http://localhost:8181/realms/spring-boot-microservices-realm/protocol/openid-connect/token
Client ID: spring-cloud-client
Secret: from 8181 server
Scope: openid offline_access
Get New Access Token
Use Token

Resilience4J Circuit Breaker: For resilient apps. fail fast and respond fast. Avoid cascading failure.
It is nothing maintaining set of stats in the app. Open -> Half open -> Closed -> Open.
Doc: https://resilience4j.readme.io/docs
SneakyThrows for catching the exceptions(not for prod env).
when Timeout and then some retry can be implemented.
Ex: Application.properties config
resilience4j.timelimiter.instances.inventory.timeout-duration=3s @TimeLimiter
resilience4j.retry.instances.inventory.max-attempts=3 @Retry
resilience4j.retry.instances.inventory.wait-duration=5s @Retry

http://localhost:8081/actuator/health to check circuit-breaker status
http://localhost:8081/actuator/
http://localhost:8081/actuator/retryevents
http://localhost:8081/actuator/timelimiterevents


Distributed Tracing:
It helps us to track the request from start to finish and help in debugging the issue.
Ex-> Why a request failed and where it failed ?
traceId is used to identify a request, spanId(number of trips a request is taking inside the system)
traceId unique identifier for whole request from start to end.
spanId unique identifier at every step or service(api-gateway -> span1, order -> span2)
So, a combination of both trace and span id is used to identify performance and issues for a request.

Sleuth and zipkin is used: https://zipkin.io/pages/quickstart.html
docker run -d -p 9411:9411 openzipkin/zipkin
http://localhost:9411/zipkin/

Debug logs with traceId and spanID: INFO [product-service,0e6782babf7a223b,ce94079375c18f4b]
We are calling inventory service in a new thread, so it's considered as a new request.
If we remove circuit breaker and Completable and rerun we would be able to see the complete path
from api-gateway -> order-service -> inventory-service in zipkin server.
To be able to trace for threads as well we need to enable/create own spans. Tracer from Sleuth.

Event Driven Architecture using Kafka:
order-service is producer and notification-service is consumer
docker: https://developer.confluent.io/quickstart/kafka-docker/
docker-compose.yml
open terminal and go to microservices-new having docker-compose.yml and run
docker compose up -d
https://spring.io/projects/spring-kafka
https://docs.spring.io/spring-kafka/reference/html/
order-service will send notification and notification-service is subscribed to order-service.
order-service is producer: kafkaTemplate.send("notificationTopic", ) sending topic and
notification-service is consumer, consuming the topic defined in application.properties.


Dockerize the application:
jib builds containers without using a Dockerfile or requiring a Docker installation: https://cloud.google.com/java/getting-started/jib


complete code: https://github.com/SaiUpadhyayula/spring-boot-microservices
